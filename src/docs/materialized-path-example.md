# Materialized Path 物化路径示例：三叉树

本文档通过一个具体的三叉树示例，详细讲解 Bark 扩展中 `path`、`depth`、`numchild` 三个字段的生成规则。
> 通过这个文档主要是为了稍微了解这个物化路径的逻辑原理，对功能扩展的理解会很有帮助，但是不必深入。

---

## 1. 示例树结构

以下是一棵**三叉树**（每个节点有 3 个子节点），**深度为 4**：

```text
Root1 [path: 0001, depth: 1, numchild: 3]
├── R1-C1 [path: 00010001, depth: 2, numchild: 3]
│   ├── R1-C1-C1 [path: 000100010001, depth: 3, numchild: 3]
│   │   ├── L1 [path: 0001000100010001, depth: 4, numchild: 0]
│   │   ├── L2 [path: 0001000100010002, depth: 4, numchild: 0]
│   │   └── L3 [path: 0001000100010003, depth: 4, numchild: 0]
│   ├── R1-C1-C2 [path: 000100010002, depth: 3, numchild: 3]
│   │   ├── L1 [path: 0001000100020001, depth: 4, numchild: 0]
│   │   ├── L2 [path: 0001000100020002, depth: 4, numchild: 0]
│   │   └── L3 [path: 0001000100020003, depth: 4, numchild: 0]
│   └── R1-C1-C3 [path: 000100010003, depth: 3, numchild: 3]
│       ├── L1 [path: 0001000100030001, depth: 4, numchild: 0]
│       ├── L2 [path: 0001000100030002, depth: 4, numchild: 0]
│       └── L3 [path: 0001000100030003, depth: 4, numchild: 0]
├── R1-C2 [path: 00010002, depth: 2, numchild: 3]
│   ├── R1-C2-C1 [path: 000100020001, depth: 3, numchild: 3]
│   │   └── ... (3个叶子节点)
│   ├── R1-C2-C2 [path: 000100020002, depth: 3, numchild: 3]
│   │   └── ...
│   └── R1-C2-C3 [path: 000100020003, depth: 3, numchild: 3]
│       └── ...
└── R1-C3 [path: 00010003, depth: 2, numchild: 3]
    ├── R1-C3-C1 [path: 000100030001, depth: 3, numchild: 3]
    │   └── ...
    ├── R1-C3-C2 [path: 000100030002, depth: 3, numchild: 3]
    │   └── ...
    └── R1-C3-C3 [path: 000100030003, depth: 3, numchild: 3]
        └── ...

Root2 [path: 0002, depth: 1, numchild: 3]
├── R2-C1 [path: 00020001, depth: 2, numchild: 3]
│   └── ... (同样结构)
├── R2-C2 [path: 00020002, depth: 2, numchild: 3]
│   └── ...
└── R2-C3 [path: 00020003, depth: 2, numchild: 3]
    └── ...

Root3 [path: 0003, depth: 1, numchild: 3]
└── ... (同样结构)
```

---

## 2. path 生成规则

### 2.1 基本规则

```text
子节点 path = 父节点 path + 格式化(序号)
```

- 每层增加 **4 位**编码（Bark 默认配置）
- 序号从 1 开始，用 36 进制表示（0-9, A-Z）
- 不足 4 位时左侧补 0

### 2.2 示例解析

| 节点名 | path | 解析 |
|--------|------|------|
| Root1 | `0001` | 第 1 个根节点 |
| Root2 | `0002` | 第 2 个根节点 |
| R1-C1 | `00010001` | Root1 的第 1 个子节点 |
| R1-C2 | `00010002` | Root1 的第 2 个子节点 |
| R1-C1-C1 | `000100010001` | R1-C1 的第 1 个子节点 |
| R1-C1-C2 | `000100010002` | R1-C1 的第 2 个子节点 |

### 2.3 path 分段解读

以路径 `0001000100020003` 为例：

```text
0001 / 0001 / 0002 / 0003
 ↓      ↓      ↓      ↓
根节点  第1层   第2层   第3层
(Root1) (C1)   (C2)   (C3)
```

意思是：**Root1 → 第1个子节点 → 第2个孙节点 → 第3个曾孙节点**

---

## 3. depth 生成规则

### 3.1 计算公式

```text
depth = path 长度 ÷ 每层位数
depth = path.length ÷ 4
```

### 3.2 示例

| path | 长度 | depth | 说明 |
|------|------|-------|------|
| `0001` | 4 | 1 | 根节点 |
| `00010001` | 8 | 2 | 第 2 层 |
| `000100010001` | 12 | 3 | 第 3 层 |
| `0001000100010001` | 16 | 4 | 第 4 层（叶子）|

---

## 4. numchild 生成规则

### 4.1 定义

`numchild` = **该节点当前已创建的直接子节点数量**

> 注意：不是"将要创建的子节点数"，也不是"所有后代节点数"，只是**直接子节点**的数量。

### 4.2 特点

| 节点类型 | numchild 值 |
|----------|-------------|
| 中间节点（有子节点）| 子节点数量（本例中为 3）|
| 叶子节点（无子节点）| 0 |

### 4.3 numchild 的作用

Bark 通过以下公式生成新子节点的 path：

```text
新子节点 path = 父节点 path + 格式化(父节点 numchild + 1)
```

例如，当 R1-C1 的 `numchild = 2` 时，再创建一个子节点：

- 新 path = `00010001` + `0003` = `000100010003`
- 然后 R1-C1 的 numchild 更新为 3

---

## 5. 统计汇总

### 5.1 各层节点数量

| depth | 节点数量 | 计算公式 | path 长度 |
|-------|----------|----------|-----------|
| 1 | 3 | 3¹ | 4 位 |
| 2 | 9 | 3² | 8 位 |
| 3 | 27 | 3³ | 12 位 |
| 4 | 81 | 3⁴ | 16 位 |
| **总计** | **120** | 3¹+3²+3³+3⁴ | - |

### 5.2 numchild 分布

| 节点类型 | 数量 | numchild 值 |
|----------|------|-------------|
| 根节点 (depth=1) | 3 | 3 |
| 中间节点 (depth=2) | 9 | 3 |
| 中间节点 (depth=3) | 27 | 3 |
| 叶子节点 (depth=4) | 81 | 0 |

---

## 6. 物化路径的查询优势

### 6.1 查询祖先链

已知节点 path = `0001000100020003`，获取所有祖先：

```text
截取前 4 位：0001          → Root1
截取前 8 位：00010001      → R1-C1
截取前 12 位：000100010002 → R1-C1-C2
```

**优势**：只需字符串截取，无需递归查询数据库。

### 6.2 查询所有后代

已知节点 path = `00010001`，查询所有后代：

```sql
SELECT * FROM categories WHERE path LIKE '00010001%' AND path != '00010001'
```

**优势**：单次查询获取所有后代，无需遍历树结构。

### 6.3 判断祖先/后代关系

```text
A 是 B 的祖先？ → B.path.startsWith(A.path) && A.path !== B.path
A 是 B 的后代？ → A.path.startsWith(B.path) && A.path !== B.path
```

**优势**：O(1) 时间复杂度的字符串比较。

---

## 相关文档

- [Prisma Bark 学习笔记](./prisma-bark.md)
